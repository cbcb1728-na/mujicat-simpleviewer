<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Mujineko-Viewer Tool</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/openseadragon/4.1.0/openseadragon.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

<style>
/* =========================================
   基本レイアウト・デザイン
========================================= */
:root {
  --control-bg: #f8f9fa;
  --border-color: #ddd;
  --viewer-bg: #1a1a1a;
  --accent-color: #0056b3;
}

body {
  margin: 0; padding: 0; height: 100vh; display: flex; flex-direction: column; overflow: hidden;
  font-family: "Helvetica Neue", Arial, "Hiragino Kaku Gothic ProN", sans-serif;
  color: #333;
}

button { cursor: pointer; border: 1px solid #ccc; background: #fff; border-radius: 4px; padding: 4px 8px; font-size: 12px; transition: 0.2s; }
button:hover { background: #e9ecef; }
button:disabled { opacity: 0.6; cursor: not-allowed; }

/* 上部コントロールバー */
#topBar {
  padding: 6px 10px; background: var(--control-bg); border-bottom: 1px solid var(--border-color);
  display: flex; flex-wrap: wrap; gap: 10px; align-items: center; justify-content: space-between; z-index: 100; box-shadow: 0 2px 4px rgba(0,0,0,0.05);
}
.left-controls, .right-controls { display: flex; gap: 8px; align-items: center; }
.control-group { display: flex; gap: 4px; align-items: center; border-right: 1px solid #ccc; padding-right: 8px; }
.control-group:last-child { border-right: none; }

#manifestUrl { font-size: 12px; padding: 4px; width: 160px; border: 1px solid #ccc; border-radius: 4px; }
#pageSelect { font-size: 12px; padding: 2px; border: 1px solid #ccc; border-radius: 4px; }

/* メインエリア */
#mainArea { flex: 1; position: relative; display: flex; overflow: hidden; background: var(--viewer-bg); }
#viewer { flex: 1; height: 100%; width: 100%; }

/* ビューワー上の画像調整ボタン */
#viewerControls {
  position: absolute; top: 15px; left: 15px; z-index: 50;
  display: flex; flex-direction: column; gap: 5px; background: rgba(255, 255, 255, 0.85);
  padding: 6px; border-radius: 6px; backdrop-filter: blur(4px); box-shadow: 0 2px 6px rgba(0,0,0,0.2);
}
#viewerControls button { font-size: 12px; padding: 0; width: 30px; height: 30px; border: 1px solid #aaa; font-weight: bold; }

/* スライドインするメモパネル */
#notesPanel {
  position: absolute; top: 0; right: -320px; 
  width: 320px; height: 100%; background: #fff; box-shadow: -4px 0 15px rgba(0,0,0,0.2);
  transition: right 0.3s cubic-bezier(0.25, 0.8, 0.25, 1); z-index: 60;
  display: flex; flex-direction: column;
}
#notesPanel.open { right: 0; }

#notesHeader { padding: 10px; background: #f0f0f0; border-bottom: 1px solid #ddd; font-weight: bold; font-size: 13px; display: flex; justify-content: space-between; align-items: center; flex-shrink: 0; }

/* メモ分割とリサイザー */
#globalNoteSection { height: 50%; display: flex; flex-direction: column; flex-shrink: 0; }
#pageNoteSection { flex: 1; display: flex; flex-direction: column; min-height: 0; }
.note-title { padding: 6px 10px; font-size: 11px; font-weight: bold; color: #555; background: #fafafa; border-bottom: 1px solid #eee; flex-shrink: 0; }
.note-textarea { flex: 1; width: 100%; box-sizing: border-box; resize: none; border: none; padding: 10px; font-size: 13px; line-height: 1.6; outline: none; }

/* 上下リサイザー */
.resizer-h {
  height: 6px; background: #e0e0e0; cursor: row-resize; flex-shrink: 0;
  border-top: 1px solid #ccc; border-bottom: 1px solid #ccc; transition: background 0.2s;
}
.resizer-h:hover { background: #bbb; }

/* 強調ボタン */
.btn-primary { background: var(--accent-color); color: #fff; border-color: var(--accent-color); font-weight: bold; }
.btn-primary:hover { background: #004494; color: #fff; }
.btn-action { font-weight: bold; color: #333; }
.btn-save { font-weight: bold; color: #006600; background: #e6ffe6; border-color: #b3ffb3; }
</style>
</head>
<body>

<div id="topBar">
  <div class="left-controls">
    <div class="control-group">
      <input type="text" id="manifestUrl" placeholder="IIIFマニフェストURL">
      <button onclick="loadManifest()" class="btn-primary">読込</button>
    </div>
    <div class="control-group">
      <button onclick="nextPage()">◀</button>
      <select id="pageSelect" onchange="jumpPage(this.value)"></select>
      <button onclick="prevPage()">▶</button>
    </div>
    <div class="control-group">
      <button onclick="downloadFullImage()" class="btn-action" title="現在のページの高画質画像をJPG保存">⬇️ 1頁</button>
      <button onclick="downloadMultipleZip()" class="btn-action" id="btnMultiZip" title="複数ページをZIPで一括保存">🗂️ 複数ZIP</button>
      <button onclick="downloadMultiplePdf()" class="btn-action" id="btnMultiPdf" title="複数ページを1つのPDFにまとめて保存">📄 複数PDF</button>
    </div>
  </div>
  
  <div class="right-controls">
    <div class="control-group">
      <button onclick="exportSession()" class="btn-save">💾 メモ保存</button>
      <button onclick="document.getElementById('sessionLoader').click()" class="btn-action">📂 読込</button>
      <input type="file" id="sessionLoader" style="display:none" accept=".json">
    </div>
    <div class="control-group" style="border:none;">
      <button onclick="toggleNotes()" class="btn-action">📝 メモ開閉</button>
    </div>
  </div>
</div>

<div id="mainArea">
  <div id="viewerControls">
    <button onclick="toggleFilter('contrast')" title="コントラスト強調">濃</button>
    <button onclick="toggleFilter('invert')" title="白黒反転">転</button>
    <button onclick="resetFilters()">解</button>
    <div style="height:1px; background:#aaa; margin:2px 0;"></div>
    <button onclick="rotate(-90)">↶</button>
    <button onclick="rotate(90)">↷</button>
  </div>
  
  <div id="viewer"></div>

  <div id="notesPanel">
    <div id="notesHeader">
      <span>📝 メモパネル</span>
      <button onclick="toggleNotes()" style="padding:2px 6px; font-size:10px;">✖ 閉じる</button>
    </div>
    
    <div id="globalNoteSection">
      <div class="note-title">全体メモ（全ページ共通）</div>
      <textarea id="globalNotesTextarea" class="note-textarea" placeholder="作品全体に関するメモなどを自由に入力できます。"></textarea>
    </div>
    
    <div id="noteResizer" class="resizer-h"></div>
    
    <div id="pageNoteSection">
      <div class="note-title">各頁メモ（現在のページ）</div>
      <textarea id="pageNotesTextarea" class="note-textarea" placeholder="表示中のページに関するメモを入力できます。"></textarea>
    </div>
  </div>
</div>

<script>
let images = [], notesData = [], globalNote = "", currentPage = 0;
let filterState = { contrast: false, invert: false };

const pSelect = document.getElementById("pageSelect");
const globalTextarea = document.getElementById("globalNotesTextarea");
const pageTextarea = document.getElementById("pageNotesTextarea");
const notesPanel = document.getElementById("notesPanel");

const viewer = OpenSeadragon({
  id: "viewer", prefixUrl: "https://cdnjs.cloudflare.com/ajax/libs/openseadragon/4.1.0/images/",
  showNavigator: true, navigatorPosition: "BOTTOM_LEFT", navigatorWidth: "120px", navigatorHeight: "120px",
  animationTime: 0.4, gestureSettingsMouse: { clickToZoom: true },
  preserveViewport: true, visibilityRatio: 0.5
});

/* --- メモパネルの上下リサイズ機能 --- */
let isResizingNote = false;
const noteResizer = document.getElementById("noteResizer");
const globalNoteSection = document.getElementById("globalNoteSection");
const notesHeader = document.getElementById("notesHeader");

noteResizer.addEventListener("mousedown", (e) => {
    isResizingNote = true; document.body.style.cursor = 'row-resize'; e.preventDefault();
});
document.addEventListener("mousemove", (e) => {
    if (!isResizingNote) return;
    const panelRect = notesPanel.getBoundingClientRect();
    const headerHeight = notesHeader.offsetHeight;
    let y = e.clientY - panelRect.top - headerHeight;
    const availableHeight = panelRect.height - headerHeight - noteResizer.offsetHeight;
    let percentage = (y / availableHeight) * 100;
    if (percentage < 10) percentage = 10; if (percentage > 90) percentage = 90;
    globalNoteSection.style.height = percentage + "%";
});
document.addEventListener("mouseup", () => {
    if (isResizingNote) { isResizingNote = false; document.body.style.cursor = ''; }
});

function toggleNotes() { notesPanel.classList.toggle('open'); }
function applyFilters() {
    const canvases = document.querySelectorAll('#viewer canvas');
    let s = "";
    if (filterState.contrast) s += "contrast(250%) grayscale(80%) ";
    if (filterState.invert) s += "invert(100%) ";
    canvases.forEach(c => { c.style.filter = s.trim(); });
}
function toggleFilter(t) { filterState[t] = !filterState[t]; applyFilters(); }
function resetFilters() { filterState = { contrast: false, invert: false }; applyFilters(); viewer.viewport.setRotation(0); viewer.viewport.goHome(); }
function rotate(d) { viewer.viewport.setRotation(viewer.viewport.getRotation() + d); }

function autoSave() {
    localStorage.setItem("viewer_images", JSON.stringify(images));
    localStorage.setItem("viewer_notes", JSON.stringify(notesData));
    localStorage.setItem("viewer_global_note", globalNote);
    localStorage.setItem("viewer_page", currentPage);
}
function autoLoad() {
    images = JSON.parse(localStorage.getItem("viewer_images")) || [];
    notesData = JSON.parse(localStorage.getItem("viewer_notes")) || [];
    globalNote = localStorage.getItem("viewer_global_note") || "";
    currentPage = parseInt(localStorage.getItem("viewer_page")) || 0;
    globalTextarea.value = globalNote;
    if (images.length > 0) { updatePageInfo(); loadPage(); }
}
window.addEventListener('DOMContentLoaded', autoLoad);

function saveNotes() { notesData[currentPage] = pageTextarea.value; globalNote = globalTextarea.value; autoSave(); }
pageTextarea.addEventListener("input", saveNotes);
globalTextarea.addEventListener("input", saveNotes);

function exportSession() {
    saveNotes();
    const data = { images, notesData, globalNote, currentPage };
    const blob = new Blob([JSON.stringify(data)], {type: "application/json"});
    const a = document.createElement("a"); a.href = URL.createObjectURL(blob); a.download = "viewer_session.json"; a.click();
}
document.getElementById("sessionLoader").addEventListener("change", function(e) {
    const file = e.target.files[0]; if (!file) return;
    const reader = new FileReader();
    reader.onload = ev => {
        try {
            const data = JSON.parse(ev.target.result);
            images = data.images || []; notesData = data.notesData || [];
            globalNote = data.globalNote || ""; currentPage = data.currentPage || 0;
            globalTextarea.value = globalNote; updatePageInfo(); loadPage();
            alert("セッションを読み込みました！");
        } catch(err) { alert("失敗しました。"); }
    };
    reader.readAsText(file); e.target.value = "";
});

async function loadManifest() {
    const url = document.getElementById('manifestUrl').value.trim(); if (!url) return;
    try {
        const res = await fetch(url); const json = await res.json();
        let canvases = (json.sequences) ? json.sequences[0].canvases : json.items;
        images = canvases.map(c => {
            if (c.images) return c.images[0].resource.service['@id'] + '/info.json';
            if (c.items) return c.items[0].items[0].body.service[0]['@id'] || c.items[0].items[0].body.service['id'];
            return null;
        }).filter(Boolean);
        notesData = new Array(images.length).fill(""); globalNote = ""; globalTextarea.value = ""; currentPage = 0;
        loadPage(); alert("IIIFを読み込みました");
    } catch (e) { alert("読み込み失敗"); }
}

function loadPage() {
    const imgUrl = images[currentPage]; if (imgUrl) viewer.open(imgUrl);
    pageTextarea.value = notesData[currentPage] || ""; updatePageInfo(); autoSave();
}
function updatePageInfo() {
    const total = images.length || 1; pSelect.innerHTML = "";
    for (let i = 0; i < total; i++) {
        const opt = document.createElement("option"); opt.value = i; opt.innerText = (i + 1) + " / " + total;
        if (i === currentPage) opt.selected = true; pSelect.appendChild(opt);
    }
}
function jumpPage(val) { saveNotes(); currentPage = parseInt(val); loadPage(); }
function prevPage() { if (currentPage > 0) { saveNotes(); currentPage--; loadPage(); } }
function nextPage() { if (currentPage < images.length - 1) { saveNotes(); currentPage++; loadPage(); } }

/* --- 1ページ高画質ダウンロード --- */
async function downloadFullImage() {
    const imgUrl = images[currentPage]; if (!imgUrl) return alert("画像がありません。");
    const downloadUrl = imgUrl.replace(/\/info\.json$/, '/full/full/0/default.jpg');
    try {
        const response = await fetch(downloadUrl); const blob = await response.blob();
        const url = window.URL.createObjectURL(blob); const a = document.createElement('a');
        a.style.display = 'none'; a.href = url; a.download = `page_${currentPage + 1}.jpg`;
        document.body.appendChild(a); a.click(); window.URL.revokeObjectURL(url); document.body.removeChild(a);
    } catch (e) { window.open(downloadUrl, '_blank'); }
}

/* --- ヘルパー関数: ページ範囲の入力とバリデーション --- */
function getPageRange() {
    if (images.length === 0) { alert("画像がありません。"); return null; }
    const input = prompt(`保存するページの範囲をハイフンで入力してください。\n(例: 1-5)\n※最大ページ数: ${images.length}`);
    if (!input) return null;
    const parts = input.split('-'); if (parts.length !== 2) { alert("1-5 のように入力してください。"); return null; }
    const start = parseInt(parts[0]) - 1, end = parseInt(parts[1]) - 1;
    if (isNaN(start) || isNaN(end) || start < 0 || end >= images.length || start > end) { alert("正しいページ範囲を指定してください。"); return null; }
    return { start, end };
}

/* --- 複数ページ一括ZIP保存機能 --- */
async function downloadMultipleZip() {
    const range = getPageRange(); if (!range) return;
    const { start, end } = range;
    
    const btn = document.getElementById('btnMultiZip'); 
    const originalText = btn.innerText;
    btn.innerText = "⏳ ZIP作成中..."; btn.disabled = true;

    try {
        const zip = new JSZip(); let successCount = 0;
        for (let i = start; i <= end; i++) {
            const imgUrl = images[i].replace(/\/info\.json$/, '/full/full/0/default.jpg');
            try {
                const response = await fetch(imgUrl); if (!response.ok) throw new Error("Network error");
                const blob = await response.blob();
                zip.file(`page_${String(i + 1).padStart(3, '0')}.jpg`, blob); successCount++;
                btn.innerText = `⏳ ZIP作成中 (${successCount}/${end - start + 1})`;
            } catch (err) { console.warn(`頁 ${i + 1} 失敗`); }
        }
        if (successCount === 0) { alert("取得失敗。提供元のセキュリティ設定により一括保存が許可されていない可能性があります。"); } 
        else {
            const content = await zip.generateAsync({ type: "blob" });
            const url = window.URL.createObjectURL(content); const a = document.createElement('a');
            a.href = url; a.download = `images_${start + 1}-${end + 1}.zip`;
            document.body.appendChild(a); a.click(); window.URL.revokeObjectURL(url); document.body.removeChild(a);
        }
    } finally { btn.innerText = originalText; btn.disabled = false; }
}

/* --- 複数ページ一括PDF保存機能 --- */
async function downloadMultiplePdf() {
    const range = getPageRange(); if (!range) return;
    const { start, end } = range;

    const btn = document.getElementById('btnMultiPdf'); 
    const originalText = btn.innerText;
    btn.innerText = "⏳ PDF作成中..."; btn.disabled = true;

    try {
        const { jsPDF } = window.jspdf;
        const pdf = new jsPDF('p', 'pt', 'a4'); 
        let isFirstPage = true;
        let successCount = 0;

        for (let i = start; i <= end; i++) {
            const imgUrl = images[i].replace(/\/info\.json$/, '/full/full/0/default.jpg');
            try {
                const response = await fetch(imgUrl);
                if (!response.ok) throw new Error("Network error");
                const blob = await response.blob();
                const objectUrl = URL.createObjectURL(blob);
                
                const img = new Image();
                img.src = objectUrl;
                await new Promise((resolve, reject) => {
                    img.onload = resolve; img.onerror = reject;
                });

                const pdfWidth = img.width; const pdfHeight = img.height;
                const orientation = pdfWidth > pdfHeight ? 'l' : 'p';

                if (isFirstPage) {
                    pdf.deletePage(1);
                    pdf.addPage([pdfWidth, pdfHeight], orientation);
                    isFirstPage = false;
                } else {
                    pdf.addPage([pdfWidth, pdfHeight], orientation);
                }

                const canvas = document.createElement('canvas');
                canvas.width = img.width; canvas.height = img.height;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0);
                const dataUrl = canvas.toDataURL('image/jpeg', 0.8); 

                pdf.addImage(dataUrl, 'JPEG', 0, 0, pdfWidth, pdfHeight);
                URL.revokeObjectURL(objectUrl);
                successCount++;
                btn.innerText = `⏳ PDF作成中 (${successCount}/${end - start + 1})`;
                
            } catch (err) { console.warn(`頁 ${i + 1} 失敗`, err); }
        }

        if (successCount === 0) {
            alert("画像の取得に失敗しました。");
        } else {
            pdf.save(`document_${start + 1}-${end + 1}.pdf`);
            if (successCount < (end - start + 1)) {
                alert(`一部の画像が取得できませんでしたが、取得できた ${successCount} ページをPDF化しました。`);
            }
        }
    } finally { btn.innerText = originalText; btn.disabled = false; }
}

/* --- キーボードの矢印キーでページめくり（右開き用） --- */
document.addEventListener('keydown', function(event) {
    // 入力欄（マニフェストURLやメモ欄）にカーソルがある時は、ページ送りを無効にする
    const activeTag = event.target.tagName.toLowerCase();
    if (activeTag === 'input' || activeTag === 'textarea') {
        return;
    }
    
    // 左矢印(←)で「次へ」、右矢印(→)で「前へ」
    if (event.key === 'ArrowLeft') {
        event.preventDefault();     // ブラウザやビューワーの本来の動き（スクロール等）をキャンセル
        event.stopPropagation();    // ビューワーにキー操作が伝わるのを防ぐ
        nextPage();
    } else if (event.key === 'ArrowRight') {
        event.preventDefault();
        event.stopPropagation();
        prevPage();
    }
}, true); // ← ここに "true" を付けることで、ビューワーより先にこのキー操作を最優先で処理させます

</script>
</body>
</html>